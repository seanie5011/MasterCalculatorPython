import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from io import StringIO

from features.CurveFitting import CurveFit
from features.helpers import convert_df_to_xy, convert_xy_to_df

def main():
    # --- Main
    # explanation
    st.markdown('''
    # :page_with_curl: Curve-Fitting

    In this App the user can enter $x$ and $y$ data from a file, this data will be fitted to return estimated parameters.
    The user can select their desired equation form to fit to, along with certain parameters. There is basic plotting functionality and the
    ability to download the new data-set generated by the algorithm.

    ## :floppy_disk: Input Data

    You can select the `Browse files` button below to search for your Data File. It is **necessary** to only use numeric digits in this file,
    with no headers, just the raw-data. It is *recommended* that this file be in the `.csv` format, with no spaces between columns or data-points, 
    and with a comma `,` as the delimeter.

    Note that the file will select only the **first two columns** you provide.

    *Types supported: `.csv`, `.txt`*
    ''')

    # - Initialise
    df = None
    functions = {
            'Linear': 2,
            'Quadratic': 3,
            'Cubic': 4,
    }  # dict used to indicate how many parameters are needed with radio

    parameters = 'abcdefghijklmnopqrstuvwxyz'  # determines letters of parameters

    # - Set Data
    # uploaded file
    @st.experimental_memo(max_entries=1)  # only 1 allowed file at a time
    def read_file(file):
        '''
        Usage:
            Reads the first 2 columns of an input file, labels them as 'x' and 'y', and sets type to float
            Extra functionality to reset fit button session state
        Inputs:
            file: a string path to the corresponding file
        Outputs:
            A pandas dataframe
        '''

        # if we upload new file (not same as one already in), we run this next block
        # we want to reset the fit button so as not to run it again
        if st.session_state.fit_button:
            del st.session_state.fit_button

        df = pd.read_csv(
            file,
            sep=None,
            names=['x', 'y'],
            usecols=[0, 1],
            dtype=np.float64
        )
        return df

    uploaded_file = st.file_uploader('Select your Data File here:', type=['csv', 'txt'])
    if uploaded_file is not None:
        try:
            df = read_file(uploaded_file)
        except ValueError:
            st.error('The Input Data must contain numbers only.')
        except:
            st.error('Unknown Error, please try again or report a bug.')
        else:
            with st.expander('See your Input Data:'):
                st.dataframe(df)

    # - Fit
    # equation helper functions
    def create_equation(function: str, pars=parameters) -> str:
        '''
        Usage:
            Depending on supported function input, creates a LaTeX style string of function form with desired parameters
        Inputs:
            function: a string of the function form, supported are:
                - Linear
                - Quadratic
                - Cubic
            pars: a list of strings for the parameters, enough must be passed for your desired equation, default is all letters in English Alphabet
        Outputs:
            latex_function: a string of the equation form in LaTeX style
        '''
        if function == 'Linear':
            latex_function = f'y = {pars[0]} x + {pars[1]}'
        elif function == 'Quadratic':
            latex_function = f'y = {pars[0]} x^2 + {pars[1]} x + {pars[2]}'
        elif function == 'Cubic':
            latex_function = f'y = {pars[0]} x^3 + {pars[1]} x^2 + {pars[2]} x + {pars[3]}'
        else:
            latex_function = 'function-creation-error'

        return latex_function

    # Use session states to keep track of whether or not buttons were pressed
    if 'fit_button' not in st.session_state:  # for when app is reloaded
        st.session_state.fit_button = False

    if 'guesses_button' not in st.session_state:
        st.session_state.guesses_button = False

    def fit_true_callback():  # keeps the fit button pressed in session state
        st.session_state.fit_button = True

    def fit_false_callback():  # keeps the guesses button pressed in session state, resets fit button
        st.session_state.fit_button = False
        st.session_state.guesses_button = True

    if df is not None:  # will only display if there is a file uploaded
        # explanation
        st.markdown('''
        ## :clipboard: Curve-Fit Settings

        Here you can select a couple settings for the computation. Firstly, you can select how many points to add *inbetween* your
        Input data-points - this is the resolution. Secondly, you can select the function to use. Don't be afraid to play
        with the settings, and find what works!
        ''')

        # Fit Settings
        with st.form('Fit Settings'):
            number_points_between = st.slider(
                'Number of points to add in the Fit:', 
                min_value=1, 
                max_value=100, 
                value=50, 
                step=1
            )

            fit_function = st.radio('Function to Fit to:', ('Linear', 'Quadratic', 'Cubic'))  # use on click callback function of below pars code

            st.form_submit_button('Update Fit Settings', on_click=fit_false_callback)  # runs next form, resets the plotting functions and below to false

        # fit guesses
        if st.session_state.guesses_button:
            st.markdown('''
            Now that you have chosen your desired settings, it is time to give your initial guesses of the parameters in your function:
            ''')
            with st.form('Fit Guesses'):
                # Display chosen equation form
                guess_equation = create_equation(fit_function)
                st.markdown(f'''
                You have chosen a function of form:

                ${guess_equation}$
                ''')

                amount_of_pars = functions[fit_function]
                fit_pars = [_*0 for _ in range(amount_of_pars)]  # list of zeroes of necessary length
                pars_columns = st.columns(amount_of_pars)  # more parameters, more columns, more inputs
                for index, column in enumerate(pars_columns):
                    with column:
                        fit_pars[index] = st.number_input(f'Guess for parameter: {parameters[index]}')
        
                st.form_submit_button('Fit Data', on_click=fit_true_callback)
        
        # Computation
        if st.session_state.fit_button:
            # get fitted data
            fit = CurveFit(*convert_df_to_xy(df))
            fit_popt, fit_pcov = fit.set_function(fit_function, fit_pars)
            new_df = convert_xy_to_df(
                *fit.get_new_data(number_points_between=number_points_between)
            )

            # show results
            # explanation
            st.markdown('''
            ## :mortar_board: Fit Results

            We now display the Algorithms best estimate for the optimal parameters, along with the Covariance Matrix:
            ''')

            col1, col2 = st.columns(2)
            with col1:
                st.markdown('**Optimal Parameters**')
                st.table(fit_popt)
            with col2:
                st.markdown('**Covariance Matrix**')
                st.table(fit_pcov)

            filled_equation = create_equation(fit_function, fit_popt.round(4))  # rounds each value in array to 4 decimal places
            st.markdown(f'''
            Thus, the equation is as follows (values rounded to 4-decimal places):

            ${filled_equation}$
            ''')
        
            # plotting
            # explanation
            st.markdown('''
            ## :chart_with_upwards_trend: Plotting the Fitted Data

            This is a basic plot of the Input and Fitted Data. This plot is interactive, make sure to check out the settings in the upper-right corner!  
            *Hint: You can even download this plot as a `.png` by using the Camera symbol!*
            ''')

            points = px.scatter(
                df,
                x='x',
                y='y',
                color_discrete_sequence=["#000000"]
            )

            line = px.line(
                new_df,
                x='x',
                y='y',
                color_discrete_sequence=["#FF0000"]
            )

            full_chart = go.Figure(data=line.data + points.data)
            full_chart.update_layout(title='Plot of Input and Fitted Data')
            full_chart.update_xaxes(title_text="x-data")
            full_chart.update_yaxes(title_text="y-data")

            st.plotly_chart(full_chart, use_container_width=True)

            # get yvalue for given x
            # explanation
            st.markdown('''
            ## :pencil2: Solving for a Specific Input

            Using the function as fitted above, we can find the exact y-value that would correspond to any given x-value.
            ''')

            desired_x = st.number_input(
                'Enter any x-value to get the corresponding y-value (to 8-decimal places):', 
                format="%f"
            )
            new_y = fit.get_yvalue(float(desired_x))
            st.latex(f'''
             \\left( x, y \\right) = \\left( {round(float(desired_x), 8)}, {round(new_y, 8)} \\right)
             ''')

            # new dataframe and download it
            # explanation
            st.markdown('''
            ## :open_file_folder: Raw Ouput Data
            ''')

            with st.expander('See your Output Data:'):
                st.dataframe(new_df)

            st.download_button(
                'Download Output Data as CSV',
                data=new_df.to_csv(index=False, header=False),
                file_name='curve_fit.csv'
            )

    # --- Sidebar
    with st.sidebar:
        st.markdown('''
        # :chart_with_upwards_trend: Curve-Fitting

        ## How it works:
        In this App we use *pandas* to take in user-data and manipulate
        it. Then, using *scipy*, we can fit the user-data to their desired
        equation form and plot using *plotly*. Using these parameters we can
        find a y-value for any given x-value in range. Finally, we can save
        the plotted data in a `.csv` file for the user to use elsewhere!

        ## Uses:
        Curve-Fitting is used commonly in Undergraduate Physics or Mathematics,
        for example:  
        - Visualisation Aid  
        - Find Relationships between variables  
        - Infer values of a function  
        - More...

        ## Further Reading:
        - [Curve fitting Wikipedia](https://en.wikipedia.org/wiki/Curve_fitting)  
        - [Scipy `curve_fit()` Docs](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit)  

        ## Packages Used:
        - [`streamlit`](https://docs.streamlit.io/)  
        - [`plotly`](https://plotly.com/python-api-reference/index.html)  
        - [`pandas`](https://pandas.pydata.org/docs/)  
        - [`numpy`](https://numpy.org/doc/)  
        - [`scipy`](https://docs.scipy.org/doc/scipy/)  
        ''')

if __name__ == '__main__':
    st.set_page_config(
        page_title='Curve-Fitting',
        page_icon=':chart_with_upwards_trend:',
        layout='wide',
        initial_sidebar_state='expanded'
    )
    main()
